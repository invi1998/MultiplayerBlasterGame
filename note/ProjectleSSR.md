# Projectile Server Side Rewind

```c++
#pragma once

#include "CoreMinimal.h"
#include "Weapon.h"
#include "ProjectileWeapon.generated.h"

/**
 * 投射武器类，派生自	Weapon
 */
UCLASS()
class BLASTER_API AProjectileWeapon : public AWeapon
{
	GENERATED_BODY()

public:
	virtual void Fire(const FVector& HitTarget) override;

private:
	UPROPERTY(EditAnywhere)
	TSubclassOf<class AProjectile> ProjectileClass;	// 子弹类

	UPROPERTY(EditAnywhere)
	TSubclassOf<AProjectile> ServerSideRewindProjectileClass;	// 服务端倒带子弹类
};

```

如上所示，我们的投射类武器（冲锋枪为例），它有两个子弹类，一个是属性复制的，一个不复制的，我们需要决定何时生成（或者说何时使用某个具体的类）

![image-20240329175041524](.\image-20240329175041524.png)

如图，我们有一个服务器和客户端，并且在服务器上的弹丸，要么是本地控制的，要么是非本地控制的。如果我们在服务器上，并且在本地控制托管玩家的位置，我们就会在服务端控制我们的角色，并且其他所有在服务器上的角色都会由其他的客户端控制。

现在如果我们在客户端上，我们要么是本地控制的，要么不是本地控制的。如果是本地控制的，我们就是在控制我们自己的角色，而所有其他的角色都是代理模拟的。

现在是否生成属性复制的弹丸取决于几件事。我们知道我们的武器本身有一个使用过的服务器端倒带布尔值 `bool bUseServerSideRewind = false;// 是否使用服务端倒带`，所以，我们的武器具有服务器端倒带控制变量，但是同时我们的投射类弹丸也是如此，这是因为弹丸可能想要使用服务器端倒带。

如果我们是在服务器上，我们的的武器设置为使用服务器端倒带，并且，我们是本地控制的，我们任然只是生成一个复制的弹丸，而没有在弹丸上启用服务端倒带。这是因为服务器上的本地控制角色不需要使用功能服务端倒带，服务器本地的所有计算都是权威可信的，它发射一枚射弹，并且根据弹头事件，他会立即在服务器上照成伤害，并将结果复制到客户端。

现在，对于在服务器上使用服务端倒带从武器上发射射弹的角色，如果我们不是本地控制的，那么发射炮弹的玩家就是其他客户端的角色。对于这种情况，我们只会生成一个不可复制的射弹，并且不启用服务端倒带。这是因为该客户端现在将生成他们自己本地的非复制射弹，这些射弹将会使用服务端倒带，然后根据倒带结果，客户端上的弹丸将会发送服务器的得分请求。

对于启用了Server Side Rewind(SSR)武器的客户端本地控制角色，如果该角色是本地控制的，他将会生成一个不可复制的射弹用于在该弹丸击中其计算机上的本地某人时，用来做服务端倒带计算。他将向服务端发送得分请求，以便服务端可以对其进行验证。

但是，向非本地控制的客户端角色发射的武器是为了响应多播RPG中的“发射武器”，这意味着武器是在其他人的机器上发射的。因此，即使武器在非本地控制的客户端上使用服务器端倒带，我们也会产生一个不使用服务器端倒带的炮弹。

现在，如果武器本身被设置为不使用服务器端倒带，那么在服务器上，无论我们是否受到本地控制，我们仍然会产生一个复制的投射物。未启用服务器端倒带。因此，即使客户端发射武器，炮弹仍将在服务器上产生并复制到客户端。

如果我们的武器没有设置为使用SSR，并且武器在客户端上开火，那么客户端上就不会产生炮弹，因为我们知道服务器最终会产生一个复制的炮弹，我们会在我们的机器上看到它。现在我们知道了什么时候产生复制的和非复制的射弹。